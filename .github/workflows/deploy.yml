name: Deploy

on:
  push:
    branches: [ "main" ]

permissions:
  id-token: write
  contents: read

env:
  AWS_REGION: eu-west-1
  TF_IN_AUTOMATION: "true"

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3

      - name: Set artifact name
        id: names
        run: echo "zip=lambda_$(date +'%Y%m%d%H%M%S').zip" >> $GITHUB_OUTPUT

      - name: Build Lambda package
        working-directory: app
        run: |
          pip install -r requirements.txt -t package
          cp -r *.py package/
          cd package
          zip -r ../${{ steps.names.outputs.zip }} .

      - name: Who am I?
        run: |
            aws sts get-caller-identity
            aws configure list
        
      - name: Debug env
        run: |
            echo "TF version:"; terraform version

      - name: Terraform init
        working-directory: infra
        run: terraform init -upgrade

      - name: Create/refresh state (no changes)
        working-directory: infra
        run: terraform apply -refresh-only -input=false -auto-approve

      - name: Read TF outputs (names)
        id: tfout
        working-directory: infra
        run: |
          set -euo pipefail
          echo "project=$(terraform output -raw project_name)" >> "$GITHUB_OUTPUT"
          echo "bucket=$(terraform output -raw artifact_bucket)" >> "$GITHUB_OUTPUT"

      - name: Ensure Lambda exec role is managed (import/create)
        working-directory: infra
        shell: bash
        run: |
          set -euo pipefail
          ROLE_NAME="${{ steps.tfout.outputs.project_name}}-lambda-exec"
          echo "Target exec role: $ROLE_NAME"

          if terraform state show aws_iam_role.lambda_exec >/dev/null 2>&1; then
            echo "Role already in Terraform state."
            exit 0
          fi

          AWS_ERR="$(aws iam get-role --role-name "$ROLE_NAME" >/dev/null 2>&1 || true)"

          if [ -z "$AWS_ERR" ]; then
            echo "Role exists in AWS but not in TF state; importing..."
            terraform import aws_iam_role.lambda_exec "$ROLE_NAME"
            exit 0
          fi

          if echo "$AWS_ERR" | grep -qi 'AccessDenied'; then
            echo "ERROR: AccessDenied when calling iam:GetRole for '$ROLE_NAME'."
            echo "Your deploy role needs iam:GetRole (scoped to this role). Aborting to avoid 409s."
            exit 1
          fi

          if echo "$AWS_ERR" | grep -qi 'NoSuchEntity'; then
            echo "Role not found in AWS; creating via targeted apply..."
            terraform apply -input=false -auto-approve -target=aws_iam_role.lambda_exec
            exit 0
          fi

          echo "Unexpected error from aws iam get-role:"
          echo "$AWS_ERR"
          exit 1

        # Ensure TF state knows about the bucket: import if it exists, otherwise create it
      - name: Ensure bucket managed (import or create)
        working-directory: infra
        shell: bash
        run: |
            set -euo pipefail
            BUCKET="${{ steps.tfout.outputs.artifact_bucket }}"
            if aws s3api head-bucket --bucket "$BUCKET" 2>/dev/null; then
                echo "Bucket exists in AWS. Importing into Terraform state if missing..."
                terraform state show aws_s3_bucket.artifacts >/dev/null 2>&1 || \
                    terraform import aws_s3_bucket.artifacts "$BUCKET"
            else
                echo "Bucket not found. Creating via targeted apply..."
                terraform apply -input=false -auto-approve -target=aws_s3_bucket.artifacts
            fi

        # Upload the zip (this bucket name will now be valid)
      - name: Upload artifact to S3
        run: aws s3 cp app/${{ steps.names.outputs.zip }} s3://${{ steps.tfout.outputs.artifact_bucket }}/

        # Finish with full apply (no -target here)
      - name: Terraform apply (full)
        working-directory: infra
        run: terraform apply -input=false -auto-approve -var "artifact_key=${{ steps.names.outputs.zip }}"

